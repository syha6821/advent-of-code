* Imports
#+name:imports
#+begin_src clojure :noweb yes :noweb-ref yes
  (use '[clojure.string :only (split includes? trim replace ends-with? starts-with? replace-first join)])
  (use '[clojure.string :only (split includes? trim replace ends-with? starts-with? replace-first join)])
  (use '[clojure.math :only (sqrt pow)])
  (use '[clojure.set :only (union rename-keys rename difference subset? superset?)])
  (use '[clojure.spec.alpha :only (int-in-range?)])
#+end_src

#+RESULTS: imports


* Input
#+name:inputs
#+begin_src clojure :noweb yes :noweb-ref yes
  (def input (split (slurp "./input.txt") #"\n"))
  (def sample (split (slurp "./sample.txt") #"\n"))
  (def sample2 (split (slurp "./sample2.txt") #"\n"))
#+end_src

#+RESULTS: inputs
| #'user/input   |
| #'user/sample  |
| #'user/sample2 |


* Solve
** read-input
#+name:read-input
#+begin_src clojure :noweb yes :noweb-ref yes
  (defn line->xyz [line]
    (zipmap '(:x :y :z) (map read-string (split line #","))))

  (defn read-hailstone [line]
    (let [[position velocity] (split line #"@")
          pos (line->xyz position)
          vel (line->xyz velocity)]
      {:pos pos
       :og pos
       :vel vel}))

  (defn read-input [input]
    (reduce (fn [result hailstone] (assoc result (:pos hailstone) hailstone)) {} (map read-hailstone input)))
#+end_src

#+RESULTS: read-input
| #'user/line->xyz      |
| #'user/read-hailstone |
| #'user/read-input     |

** solve-1
#+begin_src clojure :noweb yes :noweb-ref yes
  <<imports>>
  <<inputs>>
  <<read-input>>

  (defn after-one-second [hails]
    (reduce (fn [result [og-pos hail]]
              (let [new-pos (merge-with + (:pos hail) (:vel hail))]
                (assoc result og-pos (assoc hail :pos new-pos)))) {} hails))

  (defn after-n-second [hails n]
    (reduce (fn [result [og-pos hail]]
              (let [new-pos (merge-with + (:pos hail) (merge-with * (:vel hail) {:x n :y n :z n}))]
                (assoc result og-pos (assoc hail :pos new-pos)))) {} hails))

  (defn after-n-second-hail [hail n]
    (assoc hail :pos (merge-with + (:og hail) (merge-with * (:vel hail) {:x n :y n :z n}))))

  (defn calc-velocity [prev-pos current-pos time]
    (reduce #(assoc %1 (key %2) (/ (val %2) time)) {} (merge-with - current-pos prev-pos)))

  (defn make-stone [h1 h2 time]
    (let [start (:pos h1)
          vel (calc-velocity (:pos h1) (:pos h2) time)]
      {:first h1 :second h2 :pos (:pos h2) :vel vel}))

  (defn paralell? [stone hail]
    (some #(and (not= ((:pos stone) %) ((:pos hail) %)) (= ((:vel stone) %) ((:vel hail) %))) '(:x :y :z)))

  (defn cross-time [stone hail]
    (let [coords (remove #(and (= ((:pos stone) %) ((:pos hail) %)) (= ((:vel stone) %) ((:vel hail) %))) '(:x :y :z))]
      (zipmap coords (map #(/ (- ((:pos hail) %) ((:pos stone) %)) (- ((:vel stone) %) ((:vel hail) %))) coords))))

  (defn cross-point [stone hail]
    (let [times (cross-time stone hail)
          time (val (first times))]
      (and (apply = (map val times))
           (merge-with + (:pos hail) (merge-with * (:vel hail) {:x time :y time :z time})))))

  (defn cross? [stone hail]
    (and (not (paralell? stone hail))
         (cross-point stone hail)))

  (defn calc-extrema [hails]
    (let [xs (map #(:x (:pos (val %))) hails)
          ys (map #(:y (:pos (val %))) hails)
          zs (map #(:z (:pos (val %))) hails)
          x-max (apply max xs)
          x-min (apply min xs)
          y-max (apply max ys)
          y-min (apply min ys)
          z-max (apply max zs)
          z-min (apply min zs)]
      {:x-max (and (= 1 (count (filter #(= x-max %) xs))) x-max)
       :x-min (and (= 1 (count (filter #(= x-min %) xs))) x-min)
       :y-max (and (= 1 (count (filter #(= y-max %) xs))) y-max)
       :y-min (and (= 1 (count (filter #(= y-min %) xs))) y-min)
       :z-max (and (= 1 (count (filter #(= z-max %) xs))) z-max)
       :z-min (and (= 1 (count (filter #(= z-min %) xs))) z-min)}))

  (defn calc-extrema [hails]
    (let [xs (map #(:x (:pos (val %))) hails)
          ys (map #(:y (:pos (val %))) hails)
          zs (map #(:z (:pos (val %))) hails)]
      {:x-max (apply max xs)
       :x-min (apply min xs)
       :y-max (apply max ys)
       :y-min (apply min ys)
       :z-max (apply max zs)
       :z-min (apply min zs)}))

  (defn find-extrema [hails]
    (let [extrema (calc-extrema hails)]
      (some (fn [[_ {{x :x y :y z :z} :pos}]]
              (and (or (= (:x-min extrema) x) (= (:x-max extrema) x))
                   (or (= (:y-min extrema) y) (= (:y-max extrema) y))
                   (or (= (:z-min extrema) z) (= (:z-max extrema) z))
                   {:x x :y y :z z})) hails)))

  (defn find-first [hails]
    (let [found (find-extrema hails)]
      (if found found (find-first (after-one-second hails)))))

  (defn find-first [hails]
    (loop [hails hails
           count 0]
      (let [found (find-extrema hails)]
        ;; (println count)
        (if found found (recur (after-one-second hails) (inc count))))))
#+end_src

#+RESULTS:
| #'user/input               |
| #'user/sample              |
| #'user/sample2             |
| #'user/line->xyz           |
| #'user/read-hailstone      |
| #'user/read-input          |
| #'user/after-one-second    |
| #'user/after-n-second      |
| #'user/after-n-second-hail |
| #'user/calc-velocity       |
| #'user/make-stone          |
| #'user/paralell?           |
| #'user/cross-time          |
| #'user/cross-point         |
| #'user/cross?              |
| #'user/calc-extrema        |
| #'user/calc-extrema        |
| #'user/find-extrema        |
| #'user/find-first          |
| #'user/find-first          |


* Test
#+begin_src clojure :noweb yes :noweb-ref yes
  (defn divisors [num]
    (let [front (filterv #(zero? (rem num %)) (range 1 (sqrt num)))
          latter (mapv #(/ num %) front)]
      (concat front latter)))
#+end_src

#+RESULTS:
: #'user/divisors
