* Imports
#+name:imports
#+begin_src clojure :noweb yes :noweb-ref yes
  (use '[clojure.string :only (split includes? trim replace ends-with? starts-with? replace-first join)])
  (use '[clojure.string :only (split includes? trim replace ends-with? starts-with? replace-first join)])
  (use '[clojure.math :only (sqrt pow)])
  (use '[clojure.set :only (union rename-keys rename difference subset? superset?)])
  (use '[clojure.spec.alpha :only (int-in-range?)])
#+end_src

#+RESULTS: imports


* Input
#+name:inputs
#+begin_src clojure :noweb yes :noweb-ref yes
  (def input (split (slurp "./input.txt") #"\n"))
  (def sample (split (slurp "./sample.txt") #"\n"))
#+end_src

#+RESULTS: inputs
| class clojure.lang.Compiler$CompilerException |
| class clojure.lang.Compiler$CompilerException |


* Solve
** read-input
#+name:read-input
#+begin_src clojure :noweb yes :noweb-ref yes
  (defn line->xyz [line]
    (zipmap '(:x :y :z) (map read-string (split line #","))))

  (defn read-hailstone [line]
    (let [[position velocity] (split line #"@")
          pos (line->xyz position)
          vel (line->xyz velocity)]
      {:pos pos
       :vel vel}))

  (defn read-input [input]
    (reduce (fn [result hailstone] (assoc result (:pos hailstone) hailstone)) {} (map read-hailstone input)))
#+end_src

#+RESULTS: read-input
| #'user/line->xyz      |
| #'user/read-hailstone |
| #'user/read-input     |

** solve-1
#+begin_src clojure :noweb yes :noweb-ref yes
  <<imports>>
  <<inputs>>
  <<read-input>>

  (defn after-one-second [hails]
    (reduce (fn [result [_ hail]]
              (let [new-pos (merge-with + (:pos hail) (:vel hail))]
                (assoc result new-pos (assoc hail :pos new-pos)))) {} hails))

  (defn calc-velocity [prev-pos current-pos time]
    (reduce #(assoc %1 (key %2) (/ (val %2) time)) {} (merge-with - current-pos prev-pos)))

  (defn make-stone [h1 h2 time left]
    (let [start (:pos h1)
          vel (calc-velocity (:pos h1) (:pos h2) time)]
      {:pos (:pos h2) :vel vel :left left}))

  (defn paralell? [stone hail]
    (some #(and (not= ((:pos stone) %) ((:pos hail) %)) (= ((:vel stone) %) ((:vel hail) %))) '(:x :y :z)))

  (defn cross-time [stone hail]
    (let [coords (remove #(and (= ((:pos stone) %) ((:pos hail) %)) (= ((:vel stone) %) ((:vel hail) %))) '(:x :y :z))]
      (zipmap coords (map #(/ (- ((:pos hail) %) ((:pos stone) %)) (- ((:vel stone) %) ((:vel hail) %))) coords))))

  (defn cross-point [stone hail]
    (let [times (cross-time stone hail)
          time (val (first times))]
      (and (apply = (map val times))
           (merge-with + (:pos hail) (merge-with * (:vel hail) {:x time :y time :z time})))))

  (defn cross? [stone hail]
    (and (not (paralell? stone hail))
         (cross-point stone hail)))

  (defn make-guess [first time second left] {:first first :time time :second second :left left})

  (defn next-guesses [guess time]
    (conj (cond (nil? (:first guess)) (map #(-> guess
                                                (assoc :first (val %))
                                                (assoc :time time)
                                                (update :left dissoc (key %))
                                                (update :left after-one-second)) (:left guess))
                (nil? (:second guess)) (map #(-> guess
                                                 (assoc :second (val %))
                                                 (assoc :time (- time (:time guess)))
                                                 (update :left dissoc (key %))) (:left guess)))
          (update guess :left after-one-second)))

  (defn full-guess? [guess] (every? #(not (nil? (val %))) guess))

  (defn solve [input]
    (loop [time 0
           guesses [(make-guess nil 0 nil (after-one-second (read-input input)))]]
      (let [stones (map #(make-stone (:first %) (:second %) (:time %) (:left %)) (filter full-guess? guesses))
            stone (some (fn [s] (and (every? #(cross? s (val %)) (:left s)) s)) stones)]
        ;; (doseq [s stones] (println (dissoc s :left)))
        ;; (println time)
        (println (count guesses))
        (if stone
          stone
          (recur (inc time)
                 (mapcat #(next-guesses % time) (remove full-guess? guesses)))))))
#+end_src

#+RESULTS:
| #'user/input            |
| #'user/sample           |
| #'user/line->xyz        |
| #'user/read-hailstone   |
| #'user/read-input       |
| #'user/after-one-second |
| #'user/calc-velocity    |
| #'user/make-stone       |
| #'user/paralell?        |
| #'user/cross-time       |
| #'user/cross-point      |
| #'user/cross?           |
| #'user/make-guess       |
| #'user/next-guesses     |
| #'user/full-guess?      |
| #'user/solve            |
| #'user/solve            |


* Test
#+begin_src clojure :noweb yes :noweb-ref yes
  (make-stone {:pos {:x 21 :y 14 :z 12}} {:pos {:x 15 :y 16 :z 16}} 2)

  (cross-time (make-stone {:pos {:x 21 :y 14 :z 12}} {:pos {:x 15 :y 16 :z 16}} 2) {:pos {:x 17 :y 18 :z 20} :vel {:x -1 :y -1 :z -2}})
#+end_src
