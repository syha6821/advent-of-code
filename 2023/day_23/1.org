* Imports
#+name:imports
#+begin_src clojure :noweb yes :noweb-ref yes
  (use '[clojure.string :only (split includes? trim replace ends-with? starts-with? replace-first join)])
  (use '[clojure.string :only (split includes? trim replace ends-with? starts-with? replace-first join)])
  (use '[clojure.math :only (sqrt pow)])
  (use '[clojure.set :only (union rename-keys rename difference subset? superset?)])
  (use '[clojure.spec.alpha :only (int-in-range?)])
#+end_src

#+RESULTS: imports


* Input
#+name:inputs
#+begin_src clojure :noweb yes :noweb-ref yes
  (def input (split (slurp "./input.txt") #"\n"))
  (def sample (split (slurp "./sample.txt") #"\n"))
#+end_src

#+RESULTS: inputs
| class clojure.lang.Compiler$CompilerException |
| class clojure.lang.Compiler$CompilerException |


* Solve
** position
#+name:position
#+begin_src clojure :noweb yes :noweb-ref yes
  (def directions '(up right down left))

  (defn cart [f l1 l2]
    (for [x l1 y l2] (f x y)))

  (defn position [row col] {:row row :col col})

  (defn positions 
    ([width height] (cart position (range 0 height) (range 0 width)))
    ([size] (positions (:width size)) (positions :height size)))

  (def unit-positions (zipmap directions (map #(apply position %) '((-1 0) (0 1) (1 0) (0 -1)))))
  (def unit-directions (zipmap (map #(apply position %) '((-1 0) (0 1) (1 0) (0 -1))) directions))

  (defn adjacent-positions [pos] (map #(merge-with + pos %) (map val unit-positions)))
#+end_src

#+RESULTS: position
| #'user/directions         |
| #'user/cart               |
| #'user/position           |
| #'user/positions          |
| #'user/unit-positions     |
| #'user/unit-directions    |
| #'user/adjacent-positions |

** read-input
#+name:read-input
#+begin_src clojure :noweb yes :noweb-ref yes
  (defn read-map [input]
    (let [positions (positions (count (first input)) (count input))]
      (into {} (filter #(not= (:tile (val %)) \#)
                       (zipmap positions
                               (map #(hash-map :pos %1 :tile %2) positions (apply str input)))))))

  (defn start-pos [input]
    (loop [top-line (first input)
           result 0]
      (if (= (first top-line) \.)
        (position 0 result)
        (recur (rest top-line)
               (inc result)))))

  (defn end-pos [input]
    (loop [bottom-line (last input)
           result 0]
      (if (= (first bottom-line) \.)
        (position (dec (count input)) result)
        (recur (rest bottom-line)
               (inc result)))))
#+end_src

#+RESULTS: read-input
| #'user/read-map  |
| #'user/start-pos |
| #'user/end-pos   |

** solve-1
#+begin_src clojure :noweb yes :noweb-ref yes
  <<imports>>
  <<inputs>>
  <<position>>
  <<read-input>>
  (def slope-direction {\> 'right \v 'down})
  (defn slope? [tile] (let [tile (:tile tile)] (or (= tile \>) (= tile \v))))
  (defn relative-direction [pos1 pos2] (unit-directions (merge-with - pos2 pos1)))
  (defn can-step? [tile slope] (= (slope-direction (:tile slope)) (relative-direction (:pos tile) (:pos slope))))
  (defn after-slope [pos slope]
    (merge-with + pos (unit-positions (slope-direction slope))))
  (defn next-positions [tile remain-tiles]
    (filter #(let [next-tile (remain-tiles %)] (and next-tile (if (slope? next-tile) (can-step? tile next-tile) true))) (adjacent-positions (:pos tile))))

  (defn find-next-slopes [from step remain-tiles]
    (let [current-tile (remain-tiles from)
          remain-tiles (dissoc remain-tiles from)
          next-pos (next-positions current-tile remain-tiles)]
      (cond (slope? current-tile) [{:slope from :start (after-slope from (:tile current-tile)) :remain remain-tiles :step (inc step) :end false}] 
            (empty? next-pos) [{:step step :end true}]
            :else (mapcat #(find-next-slopes % (inc step) remain-tiles) next-pos))))

  (defn calc-end-steps [slope-info]
      (if (:end slope-info)
        [(:step slope-info)]
        (mapcat #(calc-end-steps %) (find-next-slopes (:start slope-info) (:step slope-info) (:remain slope-info)))))

  (defn solve-1 [input]
    (apply max (calc-end-steps {:start (start-pos input) :step 0 :remain (read-map input)})))
#+end_src

#+RESULTS:
| #'user/input              |
| #'user/sample             |
| #'user/directions         |
| #'user/cart               |
| #'user/position           |
| #'user/positions          |
| #'user/unit-positions     |
| #'user/unit-directions    |
| #'user/adjacent-positions |
| #'user/read-map           |
| #'user/start-pos          |
| #'user/end-pos            |
| #'user/slope-direction    |
| #'user/slope?             |
| #'user/relative-direction |
| #'user/can-step?          |
| #'user/after-slope        |
| #'user/next-positions     |
| #'user/find-next-slopes   |
| #'user/calc-end-steps     |
| #'user/solve-1            |


* Test
#+begin_src clojure :noweb yes :noweb-ref yes
  (calc-end-steps {:start (start-pos sample) :step 0 :remain (read-map sample)})
#+end_src
