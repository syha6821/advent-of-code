* Imports
#+name:imports
#+begin_src clojure :noweb yes :noweb-ref yes
  (use '[clojure.string :only (split includes? trim replace ends-with? starts-with? replace-first join)])
  (use '[clojure.math :only (sqrt pow)])
  (use '[clojure.set :only (union)])
#+end_src

#+RESULTS: imports

* Input
#+name:inputs
#+begin_src clojure :noweb yes :noweb-ref yes
  (def input (split (slurp "./input.txt") #"\n"))
  (def sample (split (slurp "./sample.txt") #"\n"))
#+end_src

#+RESULTS: inputs
| #'user/input  |
| #'user/sample |

* Solve
** read-input
#+name:read-input
#+begin_src clojure :noweb yes :noweb-ref yes
  (defn add-wall-to-edges [line]
    (str \# line \#))

  (defn add-borders [input]
    (let [horizontal-wall (apply str (repeat (count (first input)) "#"))]
      (map add-wall-to-edges (concat (list horizontal-wall) input (list horizontal-wall)))))

  (defn rotate-right [input]
    (let [input (reverse input)]
      (reduce (fn [result s] (map str result s)) (first input) (rest input))))

  (defn rotate-left [input]
    (let [input (map reverse input)]
      (reduce (fn [result s] (map str result s)) (first input) (rest input))))

  (defn read-input [input]
    (rotate-right (add-borders input)))
#+end_src

#+RESULTS: read-input
: #'user/read-input

** solve
#+begin_src clojure :noweb yes :noweb-ref yes
  <<imports>>
  <<inputs>>
  <<read-input>>

  (defn empty-space? [item] (= item \.))
  (defn round-rock? [item] (= item \O))
  (defn cube-rock? [item] (= item \#))
  (defn cube-rock-group? [group] (every? cube-rock? group))

  (defn round-rock-weight [round-rock-count cube-rock-num]
    (/ (* round-rock-count (+ (- cube-rock-num round-rock-count) (dec cube-rock-num))) 2))

  (defn rock-freq [line] (union {\O 0 \. 0 \# 0} (frequencies line)))

  (defn tilt-right [line]
    (loop [[group & rest-groups] (partition-by cube-rock? line)
           result ""]
      (cond (nil? group) result
            (cube-rock-group? group) (recur rest-groups (str result (apply str group)))
            :else (recur rest-groups
                         (str result
                              (let [freq (rock-freq group)
                                    rounds (apply str (repeat (freq \O) \O))
                                    empties (apply str (repeat (freq \.) \.))]
                                (str empties rounds)))))))

  (defn cycle [input]
    (loop [input input
           cycle-count 0]
      (if (= cycle-count 4)
        input
        (recur (rotate-right (map tilt-right input))
               (inc cycle-count)))))

  (defn value [input] (apply + (map (fn [line score] (* (count (filter round-rock? line)) score)) input (reverse (range 0 (count input))))))

  (defn cycle-nth-raw [n input]
    (loop [input input
           cycle-count 0]
      (if (= cycle-count n)
        input
        (recur (cycle input)
               (inc cycle-count)))))

  (defn cycle-nth [n input]
    (loop [input input
           history {}
           cycle-count 0]
      (let [found (history input)]
        (cond (= cycle-count n) input
              found (history (+ found (mod (- n found) (- cycle-count found))))
              :else (recur (cycle input)
                           (assoc history input cycle-count cycle-count input)
                           (inc cycle-count))))))
#+end_src

#+RESULTS:
| #'user/input             |
| #'user/sample            |
| #'user/add-wall-to-edges |
| #'user/add-borders       |
| #'user/rotate-right      |
| #'user/rotate-left       |
| #'user/read-input        |
| #'user/empty-space?      |
| #'user/round-rock?       |
| #'user/cube-rock?        |
| #'user/cube-rock-group?  |
| #'user/round-rock-weight |
| #'user/rock-freq         |
| #'user/tilt-right        |
| #'user/cycle             |
| #'user/cycle-nth-raw     |
| #'user/cycle-nth         |
| #'user/value             |

* Test
#+begin_src clojure :noweb yes :noweb-ref yes
#+end_src

837 too low
